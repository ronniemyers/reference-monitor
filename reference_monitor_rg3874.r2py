"""
A security layer which keeps a backup copy of a file in case it is written incorrectly.
"""

TYPE = "type"
ARGS = "args"
RETURN = "return"
EXCP = "exceptions"
TARGET = "target"
FUNC = "func"
OBJC = "objc"


class ABFile():
    def __init__(self, filename, create):
        mycontext['lock'] = createlock()

        validateFile = filename.split('.')
        if len(filename) <= 120 and (validateFile[0].islower() and validateFile[0].isalnum()):
            self.Afn = filename+'.a'
            self.Bfn = filename+'.b'

            if create:
                # if A exists: open file else create
                if self.Afn in listfiles():
                    self.Afile = openfile(self.Afn, True)
                else:
                    self.Afile = openfile(self.Afn, create)
                    self.Afile.writeat('SE', 0)
                # if B exists: open file else create
                if self.Bfn in listfiles():
                    self.Bfile = openfile(self.Bfn, True)
                else:
                    self.Bfile = openfile(self.Bfn, create)
                    self.Bfile.writeat('SE', 0)
            else:
                self.Afile = openfile(self.Afn, False)
                self.Bfile = openfile(self.Bfn, False)

    def writeat(self, data, offset):
        if offset <= len(self.Bfile.readat(None, 0)) and offset >= 0:
            # if passes offset validation, writes only to B file
            self.Bfile.writeat(data, offset)

    def readat(self, bytes, offset):
        readA = ''
        # reads only from A file
        readA = self.Afile.readat(bytes, offset)
        return readA

    def close(self):
        mycontext['lock'].acquire(True)
        if self.Bfile.readat(None, 0).startswith('S') and self.Bfile.readat(None, 0).endswith('E'):
            # valid file, replaces A with B data
            self.Afile.writeat(self.Bfile.readat(None, 0), 0)
        else:
            # invalid file, replaces B with A data
            self.Bfile.writeat(self.Afile.readat(None, 0), 0)
        self.Afile.close()
        self.Bfile.close()
        mycontext['lock'].release()


def ABopenfile(filename, create):
    return ABFile(filename, create)


sec_file_def = {"obj-type": ABFile,
                "name": "ABFile",
                "writeat": {"type": "func", "args": (str, int), "exceptions": Exception, "return": (int, type(None)), "target": ABFile.writeat},
                "readat": {"type": "func", "args": ((int, type(None)), (int)), "exceptions": Exception, "return": str, "target": ABFile.readat},
                "close": {"type": "func", "args": None, "exceptions": None, "return": (bool, type(None)), "target": ABFile.close}
                }

CHILD_CONTEXT_DEF["ABopenfile"] = {TYPE: OBJC, ARGS: (
    str, bool), EXCP: Exception, RETURN: sec_file_def, TARGET: ABopenfile}

secure_dispatch_module()
